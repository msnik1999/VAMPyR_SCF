from vampyr import vampyr3d as vp
import numpy as np

class Plotter:
    def __init__(self, origin, A, B, C, nx, ny, nz, molecule1, molecule2 = None):
        self.o = np.array(origin)
        self.A = np.array(A)
        self.B = np.array(B)
        self.C = np.array(C)
        self.nx = nx
        self.ny = ny
        self.nz = nz
        self.npts = self.nx * self.ny * self.nz
        self.molecule1 = molecule1
        self.molecule2 = molecule2
    
    def cubePlot(self, func, filename):
        file = open(filename, 'w')
        coords = self.calcCoords()
        values = self.evaluateFunction(func, coords)

        # Write header
        file.write("CUBE FILE GENERATED BY VAMPyR\n\n")
        nAtoms1 = len(self.molecule1.getAtoms())
        nAtoms2 = len(self.molecule2.getAtoms()) if self.molecule2 else 0
        file.write(f"{nAtoms1 + nAtoms2} {self.o[0]:.6e} {self.o[1]:.6e} {self.o[2]:.6e}\n")
        file.write(f"{self.nx} {self.coordA[0]:.6e} {self.coordA[1]:.6e} {self.coordA[2]:.6e}\n")
        file.write(f"{self.ny} {self.coordB[0]:.6e} {self.coordB[1]:.6e} {self.coordB[2]:.6e}\n")
        file.write(f"{self.nz} {self.coordC[0]:.6e} {self.coordC[1]:.6e} {self.coordC[2]:.6e}\n")
        for atom in self.molecule1.getAtoms():
            file.write(f"{atom.charge} {0:.6e} {atom.coords[0]:.6e} {atom.coords[1]:.6e} {atom.coords[2]:.6e}\n")
        if self.molecule2:
            for atom in self.molecule2.getAtoms():
                file.write(f"{atom.charge} {0:.6e} {atom.coords[0]:.6e} {atom.coords[1]:.6e} {atom.coords[2]:.6e}\n")

        # Write data            
        for i in range(values.shape[0]):
            file.write(f"{values[i]:.6e} ")
            if (i + 1) % 6 == 0:
                file.write("\n")
        file.close()


    def calcCoords(self):
        coords = np.zeros((self.npts, 3))
        self.coordA = self.A / (self.nx - 1)
        self.coordB = self.B / (self.ny - 1)
        self.coordC = self.C / (self.nz - 1)
        index = 0
        for i in range(self.nx):
            for j in range(self.ny):
                for k in range(self.nz):
                    coord = (self.o + i * self.coordA + j * self.coordB + k * self.coordC)
                    coords[index, :] = coord
                    index += 1
        return coords

    def evaluateFunction(self, func, coords):
        values = np.zeros(self.npts)
        for i in range(self.npts):
            values[i] = func(coords[i, :])
        return values